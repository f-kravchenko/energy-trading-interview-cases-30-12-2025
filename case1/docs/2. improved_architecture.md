# Improved Heat Pump Steering Architecture

## Executive Summary

This document presents a comprehensive redesign of the heat pump steering system to address the critical issues identified in the current implementation. The improved architecture focuses on:

- **Reliability**: State reconciliation, retry mechanisms, circuit breakers
- **Observability**: End-to-end tracing, metrics, alerting
- **Scalability**: Event-driven architecture, horizontal scaling
- **Maintainability**: Adapter pattern, clear interfaces, testability

## High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Data Ingestion Layer                        │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐     │
│  │ Spot Prices  │  │   Weather    │  │ Device Telemetry   │     │
│  │   (Pub/Sub)  │  │  (Pub/Sub)   │  │    (Pub/Sub)       │     │
│  └──────────────┘  └──────────────┘  └────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    Optimization Engine                          │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────-┐  │
│  │  • Thermal Mass Modeling                                  │  │
│  │  • Multi-Objective Optimization (cost, comfort, wear)     │  │
│  │  • Predictive Control (MPC)                               │  │
│  │  • Hysteresis & Rate Limiting                             │  │
│  └──────────────────────────────────────────────────────────-┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                   Command Orchestration                         │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────-┐  │
│  │  Temporal Workflows                                       │  │
│  │  • Command lifecycle management                           │  │
│  │  • State machine: pending → sent → ack → verified         │  │
│  │  • Retry with exponential backoff                         │  │
│  │  • Timeout handling                                       │  │
│  └──────────────────────────────────────────────────────────-┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                     OEM Adapter Layer                           │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────-┐  │
│  │ BrandA       │  │ BrandB       │  │ BrandC                │  │
│  │ Adapter      │  │ Adapter      │  │ Adapter               │  │
│  │ + Circuit    │  │ + Circuit    │  │ + Circuit             │  │
│  │   Breaker    │  │   Breaker    │  │   Breaker             │  │
│  └──────────────┘  └──────────────┘  └──────────────────────-┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  State Reconciliation Loop                      │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────-─┐  │
│  │  • Poll device telemetry (every 5-15 min)                 │  │
│  │  • Compare intended vs. actual state                      │  │
│  │  • Trigger remediation if drift detected                  │  │
│  │  • Alert on persistent failures                           │  │
│  └──────────────────────────────────────────────────────────-┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  Storage & State Management                     │
├─────────────────────────────────────────────────────────────────┤
│  ┌───────────────┐ ┌──────────────┐ ┌────────────────────────-┐ │
│  │ PostgreSQL    │ │ Firestore    │ │ ClickHouse              │ │
│  │ (Commands,    │ │ (Real-time   │ │ (Analytics,             │ │
│  │  Device State)│ │  Device      │ │  Historical Data)       │ │
│  │               │ │  Status)     │ │                         │ │
│  └───────────────┘ └──────────────┘ └────────────────────────-┘ │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────-┐  │
│  │ Redis (Caching, Rate Limiting, Distributed Locks)         │  │
│  └──────────────────────────────────────────────────────────-┘  │
└─────────────────────────────────────────────────────────────────┘
```

## Key Architectural Improvements

### 1. Event-Sourced Command Pattern

**Design:**
- All commands are stored as immutable events with full audit trail
- Command state transitions tracked: `pending → sent → acknowledged → verified → completed`
- Enable replay, debugging, and compliance

**Implementation:**

```python
from enum import Enum
from datetime import datetime
from dataclasses import dataclass
from typing import Optional

class CommandState(Enum):
    PENDING = "pending"
    SENT = "sent"
    ACKNOWLEDGED = "acknowledged"
    VERIFIED = "verified"
    COMPLETED = "completed"
    FAILED = "failed"
    RETRYING = "retrying"

@dataclass
class Command:
    id: str
    device_id: str
    generic_action: str  # e.g., "set_mode_max"
    oem_specific_payload: dict
    state: CommandState
    created_at: datetime
    sent_at: Optional[datetime]
    acknowledged_at: Optional[datetime]
    verified_at: Optional[datetime]
    completed_at: Optional[datetime]
    retry_count: int
    last_error: Optional[str]
    correlation_id: str  # for distributed tracing
```

**Benefits:**
- Complete audit trail for compliance
- Easy debugging (replay command sequence)
- Idempotent operations
- State machine ensures proper transitions

### 2. State Reconciliation Loop

**Design:**
- Periodic polling (every 5-15 minutes) of actual device state
- Compare with intended state from command history
- Automatic remediation on drift detection

**Algorithm:**

```python
async def reconciliation_loop(device_id: str):
    """
    Continuously reconcile intended vs actual device state
    """
    while True:
        # 1. Get intended state from last successful command
        intended_state = await get_intended_state(device_id)

        # 2. Get actual state from device telemetry
        actual_state = await get_device_telemetry(device_id)

        # 3. Compare states
        if not states_match(intended_state, actual_state):
            # 4. Check if drift is expected (user override, manual adjustment)
            if is_legitimate_override(device_id, actual_state):
                log_user_override(device_id, actual_state)
                update_intended_state(device_id, actual_state)
            else:
                # 5. Drift detected - trigger remediation
                await remediate_state_drift(
                    device_id=device_id,
                    intended=intended_state,
                    actual=actual_state
                )

        # 6. Sleep before next check
        await asyncio.sleep(RECONCILIATION_INTERVAL)

async def remediate_state_drift(device_id, intended, actual):
    """
    Attempt to fix state drift
    """
    # Create remediation command
    command = create_remediation_command(device_id, intended)

    # Execute with retry
    result = await execute_command_with_retry(command)

    # Alert if remediation fails after retries
    if not result.success:
        alert_ops_team(
            severity="HIGH",
            message=f"Cannot reconcile device {device_id} state",
            intended=intended,
            actual=actual
        )
```

**Benefits:**
- Self-healing system that detects and fixes drift
- Early detection of device failures or OEM API issues
- Reduced manual intervention
- Better alignment between intended and actual behavior

### 3. Adapter Pattern for OEM Integration

**Design:**
- Define standard interface that all OEM adapters implement
- Each adapter encapsulates OEM-specific API details
- Centralized adapter registry for dependency injection

**Interface Definition:**

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class OEMAdapter(ABC):
    """
    Standard interface for all OEM heat pump integrations
    """

    @abstractmethod
    async def send_command(
        self,
        device_id: str,
        command: Command
    ) -> CommandResult:
        """
        Send a command to the device via OEM API
        Returns: CommandResult with success status and telemetry
        """
        pass

    @abstractmethod
    async def get_device_state(
        self,
        device_id: str
    ) -> DeviceState:
        """
        Query current device state from OEM API
        Returns: DeviceState with current temperature, mode, etc.
        """
        pass

    @abstractmethod
    async def validate_command(
        self,
        device_id: str,
        command: Command
    ) -> ValidationResult:
        """
        Check if command is valid for this device
        Returns: ValidationResult with any constraints/warnings
        """
        pass

    @abstractmethod
    def translate_generic_command(
        self,
        generic_action: str
    ) -> Dict[str, Any]:
        """
        Translate generic command to OEM-specific payload
        E.g., "set_mode_max" → {"temperature_offset": 2, "boost": true}
        """
        pass

    @property
    @abstractmethod
    def rate_limits(self) -> RateLimitConfig:
        """
        Return OEM-specific rate limits
        """
        pass
```

**Example Implementation:**

```python
class BrandAAdapter(OEMAdapter):
    """
    Adapter for BrandA heat pumps
    """

    def __init__(self, api_client: BrandAClient, circuit_breaker: CircuitBreaker):
        self.client = api_client
        self.circuit_breaker = circuit_breaker

    async def send_command(self, device_id: str, command: Command) -> CommandResult:
        # Translate generic command to BrandA-specific
        payload = self.translate_generic_command(command.generic_action)

        try:
            # Execute with circuit breaker protection
            response = await self.circuit_breaker.call(
                self.client.post,
                f"/devices/{device_id}/commands",
                json=payload
            )

            return CommandResult(
                success=True,
                response_data=response,
                timestamp=datetime.utcnow()
            )
        except CircuitBreakerOpen:
            return CommandResult(
                success=False,
                error="Circuit breaker open - OEM API degraded"
            )
        except Exception as e:
            return CommandResult(
                success=False,
                error=str(e)
            )

    def translate_generic_command(self, generic_action: str) -> Dict[str, Any]:
        """
        Map generic actions to BrandA API calls
        """
        mapping = {
            "set_mode_max": {
                "temperature_offset": 2,
                "boost_dhw": True,
                "eco_mode": False
            },
            "set_mode_min": {
                "temperature_offset": -2,
                "boost_dhw": False,
                "eco_mode": True
            },
            "set_mode_mid": {
                "temperature_offset": 0,
                "boost_dhw": False,
                "eco_mode": False
            }
        }
        return mapping.get(generic_action, {})

    @property
    def rate_limits(self) -> RateLimitConfig:
        return RateLimitConfig(
            max_requests_per_minute=10,
            max_requests_per_hour=200,
            max_commands_per_day=500
        )
```

**Adapter Registry:**

```python
class AdapterRegistry:
    """
    Central registry for OEM adapters
    """

    def __init__(self):
        self._adapters: Dict[str, OEMAdapter] = {}

    def register(self, oem_name: str, adapter: OEMAdapter):
        self._adapters[oem_name] = adapter

    def get_adapter(self, oem_name: str) -> Optional[OEMAdapter]:
        return self._adapters.get(oem_name)

# Usage
registry = AdapterRegistry()
registry.register("brand_a", BrandAAdapter(client_a, breaker_a))
registry.register("brand_b", BrandBAdapter(client_b, breaker_b))
```

**Benefits:**
- Easy to add new OEM integrations
- Consistent interface for testing
- OEM-specific logic isolated and maintainable
- Can mock adapters for testing

### 4. Workflow Orchestration with Temporal

**Why Temporal:**
- Durable execution (survives crashes/restarts)
- Built-in retry mechanisms with exponential backoff
- Workflow state persisted automatically
- Distributed tracing and observability
- Testable workflow logic

**Command Execution Workflow:**

```python
from temporalio import workflow, activity
from datetime import timedelta

@workflow.defn
class CommandExecutionWorkflow:
    """
    Orchestrates the full lifecycle of a command
    """

    @workflow.run
    async def run(self, command: Command) -> CommandResult:
        # 1. Validate command
        validation = await workflow.execute_activity(
            validate_command,
            command,
            start_to_close_timeout=timedelta(seconds=30)
        )

        if not validation.valid:
            return CommandResult(success=False, error=validation.error)

        # 2. Send command with retry
        send_result = await workflow.execute_activity(
            send_command_to_device,
            command,
            start_to_close_timeout=timedelta(seconds=60),
            retry_policy=RetryPolicy(
                initial_interval=timedelta(seconds=5),
                maximum_interval=timedelta(minutes=5),
                maximum_attempts=5,
                backoff_coefficient=2.0
            )
        )

        if not send_result.success:
            return send_result

        # 3. Wait for acknowledgment (with timeout)
        try:
            await workflow.wait_condition(
                lambda: self.command_acknowledged,
                timeout=timedelta(minutes=2)
            )
        except TimeoutError:
            return CommandResult(
                success=False,
                error="Timeout waiting for acknowledgment"
            )

        # 4. Schedule verification check
        await workflow.sleep(timedelta(minutes=10))

        verification = await workflow.execute_activity(
            verify_command_execution,
            command,
            start_to_close_timeout=timedelta(seconds=30)
        )

        return verification
```

**Activity Implementations:**

```python
@activity.defn
async def send_command_to_device(command: Command) -> CommandResult:
    """
    Activity: Send command via OEM adapter
    """
    # Get appropriate adapter
    adapter = adapter_registry.get_adapter(command.oem_name)

    # Apply rate limiting
    await rate_limiter.acquire(command.oem_name, command.device_id)

    # Send command
    result = await adapter.send_command(command.device_id, command)

    # Update command state
    await update_command_state(
        command.id,
        CommandState.SENT if result.success else CommandState.FAILED
    )

    return result

@activity.defn
async def verify_command_execution(command: Command) -> CommandResult:
    """
    Activity: Verify command was actually executed by device
    """
    adapter = adapter_registry.get_adapter(command.oem_name)

    # Get current device state
    device_state = await adapter.get_device_state(command.device_id)

    # Check if state matches expected outcome
    expected_state = compute_expected_state(command)

    if states_match(device_state, expected_state):
        await update_command_state(command.id, CommandState.VERIFIED)
        return CommandResult(success=True)
    else:
        return CommandResult(
            success=False,
            error=f"State mismatch: expected {expected_state}, got {device_state}"
        )
```

**Benefits:**
- Automatic retries with backoff
- Workflow survives process crashes
- Clear visibility into command lifecycle
- Easy to add new steps or modify logic
- Built-in monitoring and metrics

### 5. Circuit Breaker Pattern

**Design:**
- Protect against cascading failures when OEM APIs degrade
- Three states: CLOSED (normal), OPEN (failing), HALF_OPEN (testing recovery)
- Automatic state transitions based on failure rates

**Implementation:**

```python
from enum import Enum
from datetime import datetime, timedelta
from typing import Callable, Any

class CircuitState(Enum):
    CLOSED = "closed"      # Normal operation
    OPEN = "open"          # Failing - reject requests
    HALF_OPEN = "half_open"  # Testing recovery

class CircuitBreaker:
    """
    Circuit breaker for OEM API calls
    """

    def __init__(
        self,
        failure_threshold: int = 5,      # Open after 5 failures
        success_threshold: int = 2,      # Close after 2 successes
        timeout: timedelta = timedelta(minutes=5)  # Try recovery after 5 min
    ):
        self.failure_threshold = failure_threshold
        self.success_threshold = success_threshold
        self.timeout = timeout

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None

    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """
        Execute function with circuit breaker protection
        """
        # Check if we should try recovery
        if self.state == CircuitState.OPEN:
            if datetime.utcnow() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
                self.success_count = 0
            else:
                raise CircuitBreakerOpen("Circuit breaker is OPEN")

        try:
            # Execute the function
            result = await func(*args, **kwargs)

            # Record success
            self.on_success()

            return result

        except Exception as e:
            # Record failure
            self.on_failure()
            raise

    def on_success(self):
        """Handle successful call"""
        if self.state == CircuitState.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.success_threshold:
                # Recovery successful
                self.state = CircuitState.CLOSED
                self.failure_count = 0
        else:
            # Reset failure count on success
            self.failure_count = 0

    def on_failure(self):
        """Handle failed call"""
        self.failure_count += 1
        self.last_failure_time = datetime.utcnow()

        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.OPEN
            alert_ops_team(
                severity="HIGH",
                message=f"Circuit breaker opened after {self.failure_count} failures"
            )
```

**Benefits:**
- Prevents cascading failures
- Allows system to recover gracefully
- Reduces load on failing OEM APIs
- Fast-fail instead of waiting for timeouts

### 6. Observability & Monitoring

**Metrics to Track:**

```python
# Command execution metrics
command_sent_total = Counter("commands_sent_total", ["oem", "device_id"])
command_success_total = Counter("commands_success_total", ["oem"])
command_failure_total = Counter("commands_failure_total", ["oem", "error_type"])
command_duration_seconds = Histogram("command_duration_seconds", ["oem"])
command_retry_total = Counter("command_retry_total", ["oem"])

# State reconciliation metrics
state_drift_detected_total = Counter("state_drift_detected_total", ["device_id"])
reconciliation_success_total = Counter("reconciliation_success_total")
reconciliation_failure_total = Counter("reconciliation_failure_total")

# OEM API health metrics
oem_api_latency_seconds = Histogram("oem_api_latency_seconds", ["oem", "endpoint"])
oem_api_errors_total = Counter("oem_api_errors_total", ["oem", "status_code"])
circuit_breaker_state = Gauge("circuit_breaker_state", ["oem"])  # 0=closed, 1=half_open, 2=open

# Business metrics
energy_consumption_kwh = Gauge("energy_consumption_kwh", ["device_id"])
estimated_cost_savings_eur = Gauge("estimated_cost_savings_eur", ["device_id"])
user_overrides_total = Counter("user_overrides_total", ["device_id"])
```

**Distributed Tracing:**

```python
from opentelemetry import trace
from opentelemetry.trace import Status, StatusCode

tracer = trace.get_tracer(__name__)

async def execute_command_with_tracing(command: Command):
    """
    Execute command with full distributed tracing
    """
    with tracer.start_as_current_span(
        "execute_command",
        attributes={
            "command.id": command.id,
            "command.device_id": command.device_id,
            "command.action": command.generic_action,
            "command.oem": command.oem_name
        }
    ) as span:
        try:
            # Validation span
            with tracer.start_as_current_span("validate_command"):
                validation = await validate_command(command)

            # Send span
            with tracer.start_as_current_span("send_to_oem"):
                result = await send_command(command)

            # Verification span
            with tracer.start_as_current_span("verify_execution"):
                verification = await verify_command(command)

            span.set_status(Status(StatusCode.OK))
            return verification

        except Exception as e:
            span.set_status(Status(StatusCode.ERROR, str(e)))
            span.record_exception(e)
            raise
```

**Alerting Rules:**

```yaml
# Prometheus alerting rules
groups:
  - name: heat_pump_steering
    rules:
      - alert: HighCommandFailureRate
        expr: rate(command_failure_total[5m]) > 0.1
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High command failure rate detected"

      - alert: CircuitBreakerOpen
        expr: circuit_breaker_state == 2
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Circuit breaker open for OEM {{ $labels.oem }}"

      - alert: StateDriftPersistent
        expr: increase(state_drift_detected_total[1h]) > 10
        labels:
          severity: warning
        annotations:
          summary: "Persistent state drift for device {{ $labels.device_id }}"
```

## GCP Infrastructure Architecture

### Compute & Services

```
┌─────────────────────────────────────────────────────────────────┐
│                        Compute Layer                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────────────────────────────────────────────────────-──┐  │
│  │ GKE (Google Kubernetes Engine)                            │  │
│  │                                                           │  │
│  │  • Optimization Engine (Python pods)                      │  │
│  │  • Temporal workers (command execution)                   │  │
│  │  • API Gateway (FastAPI)                                  │  │
│  │  • Reconciliation service                                 │  │
│  │                                                           │  │
│  │  Autoscaling: HPA based on queue depth & CPU              │  │
│  └──────────────────────────────────────────────────────────-┘  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────-─┐  │
│  │ Cloud Run (Serverless)                                    │  │
│  │                                                           │  │
│  │  • OEM Adapter services (one per OEM)                     │  │
│  │  • Webhook receivers (device telemetry)                   │  │
│  │  • Ad-hoc analytics queries                               │  │
│  │                                                           │  │
│  │  Autoscaling: 0 to N based on requests                    │  │
│  └─────────────────────────────────────────────────────────-─┘  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────-─┐  │
│  │ Cloud Functions                                           │  │
│  │                                                           │  │
│  │  • Pub/Sub triggers (price updates, alerts)               │  │
│  │  • Scheduled functions (daily optimization)               │  │
│  │  • Lightweight transformations                            │  │
│  └─────────────────────────────────────────────────────────-─┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Data & Messaging

```
┌─────────────────────────────────────────────────────────────────┐
│                      Data Layer                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────-┐  │
│  │ Cloud SQL (PostgreSQL)                                    │  │
│  │                                                           │  │
│  │  Tables:                                                  │  │
│  │  • commands (event sourcing)                              │  │
│  │  • devices (metadata, OEM mappings)                       │  │
│  │  • users (preferences, settings)                          │  │
│  │  • optimization_runs (results, parameters)                │  │
│  │                                                           │  │
│  │  Config: HA with read replicas, automatic backups         │  │
│  └──────────────────────────────────────────────────────────-┘  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────-─┐  │
│  │ Cloud Firestore                                           │  │
│  │                                                           │  │
│  │  Collections:                                             │  │
│  │  • device_states (real-time current state)                │  │
│  │  • user_sessions (real-time dashboard data)               │  │
│  │                                                           │  │
│  │  Use case: Low-latency reads for dashboards               │  │
│  └──────────────────────────────────────────────────────────-┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────-┐  │
│  │ ClickHouse                                                │  │
│  │                                                           │  │
│  │  Tables:                                                  │  │
│  │  • telemetry_history (device measurements)                │  │
│  │  • command_history (analytics)                            │  │
│  │  • spot_prices (historical prices)                        │  │
│  │  • cost_savings (aggregated metrics)                      │  │
│  │                                                           │  │
│  │  Use case: Analytics, ML training, reporting              │  │
│  └──────────────────────────────────────────────────────────-┘  │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────-─┐  │
│  │ Cloud Pub/Sub                                             │  │
│  │                                                           │  │
│  │  Topics:                                                  │  │
│  │  • spot-price-updates                                     │  │
│  │  • device-telemetry                                       │  │
│  │  • weather-updates                                        │  │
│  │  • command-events                                         │  │
│  │  • alerts                                                 │  │
│  └─────────────────────────────────────────────────────────-─┘  │
│                                                                 │
│  ┌────────────────────────────────────────────────────────-──┐  │
│  │ Cloud Memorystore (Redis)                                 │  │
│  │                                                           │  │
│  │  Use cases:                                               │  │
│  │  • Rate limiting per OEM                                  │  │
│  │  • Device state cache (TTL: 5 min)                        │  │
│  │  • Distributed locks for concurrency                      │  │
│  │  • Celery broker (if using Celery)                        │  │
│  └─────────────────────────────────────────────────────────-─┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Observability Stack

```
┌────────────────────────────────────────────────────────────────┐
│                   Observability Layer                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌─────────────────────────────────────────────────────────-┐  │
│  │ Cloud Logging                                            │  │
│  │  • Structured JSON logs from all services                │  │
│  │  • Log-based metrics                                     │  │
│  │  • Long-term retention (90 days)                         │  │
│  └─────────────────────────────────────────────────────────-┘  │
│                                                                │
│  ┌────────────────────────────────────────────────────────-─┐  │
│  │ Cloud Monitoring (Metrics)                               │  │
│  │  • System metrics (CPU, memory, disk)                    │  │
│  │  • Custom metrics (Prometheus format)                    │  │
│  │  • Alerting policies                                     │  │
│  └─────────────────────────────────────────────────────────-┘  │
│                                                                │
│  ┌────────────────────────────────────────────────────────-─┐  │
│  │ Cloud Trace                                              │  │
│  │  • Distributed tracing (OpenTelemetry)                   │  │
│  │  • Latency analysis                                      │  │
│  │  • Request flow visualization                            │  │
│  └─────────────────────────────────────────────────────────-┘  │
│                                                                │
│  ┌────────────────────────────────────────────────────────-─┐  │
│  │ Grafana (GKE deployment)                                 │  │
│  │  • Custom dashboards                                     │  │
│  │  • Real-time monitoring                                  │  │
│  │  • Business metrics visualization                        │  │
│  └─────────────────────────────────────────────────────────-┘  │
└────────────────────────────────────────────────────────────────┘
```

### Security & Secrets

```
┌────────────────────────────────────────────────────────────────┐
│                     Security Layer                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Secret Manager                                           │  │
│  │  • OEM API credentials                                   │  │
│  │  • Database passwords                                    │  │
│  │  • API keys                                              │  │
│  │  • Automatic rotation policies                           │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Identity & Access Management (IAM)                       │  │
│  │  • Service accounts with minimal permissions             │  │
│  │  • Workload Identity for GKE                             │  │
│  │  • Audit logging                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ Cloud Armor (DDoS protection)                            │  │
│  │  • WAF rules                                             │  │
│  │  • Rate limiting                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────┘
```

## Cost Optimization Strategies

1. **Compute:**
   - Use GKE autopilot for automatic right-sizing
   - Cloud Run for bursty workloads (pay per request)
   - Spot VMs for batch processing (70% discount)

2. **Storage:**
   - ClickHouse: Use partitioned tables by date
   - Cloud Storage: Lifecycle policies (archive old telemetry)
   - Cache frequently accessed data in Redis

3. **Network:**
   - Use Cloud CDN for API responses
   - Keep data in single region when possible
   - Use VPC peering instead of internet egress

4. **Observability:**
   - Sample traces (don't trace every request)
   - Log filtering (only errors and warnings)
   - Metrics aggregation before export

## Deployment Strategy

### Infrastructure as Code

```hcl
# Terraform example for GKE cluster
resource "google_container_cluster" "heat_pump_cluster" {
  name     = "heat-pump-steering"
  location = "europe-west1"

  # Autopilot mode for automatic management
  enable_autopilot = true

  # Network config
  network    = google_compute_network.vpc.name
  subnetwork = google_compute_subnetwork.subnet.name

  # Security
  workload_identity_config {
    workload_pool = "${var.project_id}.svc.id.goog"
  }

  # Monitoring
  monitoring_config {
    enable_components = ["SYSTEM_COMPONENTS", "WORKLOADS"]
  }
}
```

### CI/CD Pipeline

```yaml
# GitHub Actions example
name: Deploy Heat Pump Steering

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run tests
        run: |
          pytest tests/
          mypy src/

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Build Docker image
        run: docker build -t gcr.io/$PROJECT/optimization-engine:$SHA .

      - name: Push to GCR
        run: docker push gcr.io/$PROJECT/optimization-engine:$SHA

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GKE
        run: |
          kubectl set image deployment/optimization-engine \
            optimization-engine=gcr.io/$PROJECT/optimization-engine:$SHA
```

## Next Steps

The following documents provide additional details:

- [3. economic_optimization.md](3.%20economic_optimization.md) - Enhanced optimization strategies
- [4. implementation_guide.md](4.%20implementation_guide.md) - Step-by-step implementation plan
